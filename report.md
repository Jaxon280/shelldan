# 情報科学基礎実験レポート（C発展課題39）
**J2-180018 飯田夏生**

## 1. 実装したもの
　以下の機能を備えたシェルを実装した。なお、実装のコードは `./main.c` に全てまとめている。
- 外部プログラムの実行、プログラムに使う引数の受け取り
- 入出力の外部ファイルへのリダイレクト
- 複数のプログラム同士の入出力を繋げられるパイプ
- プログラムのフォアグラウンド・バックグラウンド実行
- 下記のビルトインコマンド (リダイレクトやパイプには未対応)
    - シェル上のジョブの一覧を確認する `jobs` コマンド
    - 停止したプログラムをフォアグラウンドで再開させる `fg` コマンド、バックグラウンドで再開させる `bg` コマンド

　このレポートでは、シェル全体の設計について軽く説明し、これらの機能ごとにどういった実装を行ったのかを説明する。

## 2. シェルプログラムの全体の設計
　シェルを起動すると、コマンド入力がされるたびにシェルは入力の字句解析、バックグラウンドジョブの待機、ジョブの生成とトークン列からジョブを設定していく構文解析、ジョブの実行、フォアグラウンドジョブの待機、終了したジョブのリソース解放などの後処理といった順で手続きのループが走る。（以下、「ループ」はこうしたコマンド入力ごとによるループを指す）
　

#### プログラム内の構造体の構成
シェルプログラムの主なデータの構造は以下のように、`Shell` 構造体は `Job` 構造体のリストを、`Job` 構造体は `Process` 構造体のリスト（キュー）を持つ。ただし、ジョブのリストには現在シェル上で実行中もしくは停止中の状態であるジョブのリスト `jobs` と、既に完了しリソース解放待ちであるジョブのリストの `finished_jobs` の二種類があり、ジョブは後述の状態の変更に応じてどのリストに存在するかが変化していくことになる。
```
Shell --┬- Job --┬- Process       Shell --┬- jobs         
        ├- Job   ├- Process               └- finished_jobs
        ├- Job   ├- Process
        ...      ...
```
　`Job` 構造体の下のプロセスは全て同じプロセスグループに属しており、フォアグラウンドにはシェル自体とジョブ（プロセスグループ）のうち一つのみが存在し、残りのジョブは全てバックグラウンドに存在する。ジョブを起動する際には `Process` 構造体のリストの数だけ `fork()` システムコールを呼び出すことによって、シェルプロセスの子プロセスを生成し、プログラムを子プロセス上で実行する。ただし、ビルトインコマンドは `fork()` によって新たにプロセスを生成しない。

なお、どういったコマンド入力がシェル上でなされるか分からないため、上記の「リスト」のデータ構造には固定長の配列ではなく、ジョブやプロセスの追加のたびに必要なメモリ領域を動的に確保していく連結リストを用いており、プロセスごとのコマンドやファイルパスの文字列も同様に入力をパースする段階での動的確保を行っている。ジョブの生成や構文解析の段階で動的確保を何度もしているため、メモリリークや二重解放といったバグを避けるために `finished_jobs` のリストにある終了済みのジョブはループの最後でまとめて解放している。

#### ジョブの状態変化
　ジョブの状態は以下のように変化していく。ジョブの実行が始まると初期の `Pending` から `Running` へ、`SIGTSTP` や `SIGTTIN` シグナルを捕捉した場合に `Stopped` へとなり、`fg` や `bg` コマンドによる再開でジョブは `Running` へと戻る。フォアグラウンドジョブが `Stopped` になった場合、バックグラウンドジョブへと移る。 `Done` 状態になると `finished_jobs` リストに追加され、ループの終了時にリスト内のジョブが確保しているメモリは全てまとめて解放される。ジョブの状態は基本的に `waitpid()` システムコールによってジョブに属しているプロセスの状態変化を捕捉することで変更される。

```
                                                       
(ジョブの追加) --> Pending --> Running --> Stopped   Done --> (ジョブの削除)
                                | ↖--------┘         ↑           
                                └--------------------┘         
```

## 3. シェルの各機能について
各機能の実装についてどういったシステムコールを用いたか、どういった点について気をつけたかを触れる。

#### 外部プログラムの実行
トークン列の解析の段階でコマンド入力からコマンド名と引数を `Process` 構造体と紐付ける。実行自体はジョブの実行が始まると `fork()` をした後、子プロセス内で `execv()` を呼び出すことで行い、プログラムの引数もここで与えている。

#### リダイレクト
トークン列の解析の段階でリダイレクト演算子 (`<` や `>`) トークンを読み取り、後に続くファイルパスのトークンを `Process` 構造体と紐付けている。ここで指定されたファイルのファイルディスクリプタを取得し、`dup2()` によって紐付けられたプロセスの標準入力・出力用のファイルディスクリプタへの複製を行っている。

#### パイプ
パイプがある場合、ジョブに対して新規のプロセスが追加されるので、パイプ演算子 (`|`) トークンを読み取った場合は `Process` 構造体を `Job` 構造体に新たに追加していく。パイプで繋がれたプロセスの標準入出力を繋ぐ際は、親プロセスで `pipe()` によって子プロセス間でプロセス間通信を行うパイプ用のファイルディスクリプタを生成し、`dup2()` によって各プロセスの標準入出力用のディスクリプタへ複製している。なお、リダイレクトと同じく親プロセスで開いたファイルディスクリプタは `fork()` 後に子プロセスへ複製されるので、使用しないパイプは両方のプロセスで `close()` している。
　また、フォアグラウンドジョブの中で最初に起動するプロセスの `fork()` 後に `tcsetpgrp()` を実行しているが、これは大量のパイプを繋いだジョブのフォアグラウンド実行をするとジョブがフォアグラウンドに設定される前に子プロセスの実行が始まってしまい、`SIGTTIN` シグナルなどによってジョブのプロセスが停止してしまうのを防ぐためである。

#### フォアグラウンド・バックグラウンド実行
フォアグラウンド実行の場合、`tcsetpgrp()` でフォアグラウンドプロセスグループをシェルを実行しているプロセスからフォアグラウンドで実行するジョブへと変更し、フォアグラウンドで走っているプロセスの状態変化も `waitpid()` でブロッキングで捕捉する必要がある。フォアグラウンドジョブのプロセスは全て終了したもしくはそのうち一つが停止した場合、再びシェルプロセスをフォアグラウンドにするよう変更している。
一方、`&` 演算子トークンを読み取った場合はそのジョブをバックグラウンドモードに設定する。バックグラウンドジョブは特にフォアグラウンドの変更は行わず、いつ終了もしくは停止するかシェルは知らないため `waitpid()` をループの冒頭でノンブロッキング （ `WNOHANG` オプション） で呼び出すことで、プロセスの状態変化があった時のみ捕捉してジョブの状態の変更や `jobs` リストからの削除や `finished_jobs` リストへの追加を行う。

#### `jobs` コマンド
`jobs` コマンドは停止中・実行中のジョブのリストの `jobs` にある全てのジョブを出力する。出力する情報は、ジョブの状態 / ジョブID / 入力されたジョブのコマンド である。ジョブIDは生成時にジョブリスト内でユニークになるように設定され、 `fg`, `bg` コマンドでは再開するジョブをジョブIDで指定する。

#### `fg` コマンド、`bg` コマンド
`fg`, `bg` コマンド共に `Stopped` 状態であるジョブを再開させるが、ジョブの再開にはジョブのプロセスグループに `kill()` システムコールで `SIGCONT` を送ることで再開させている。`fg` の場合、ジョブの再開後にフォアグラウンド実行用の待機処理へとジャンプする。
